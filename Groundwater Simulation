import math as m
import numpy as np
import matplotlib.pyplot as plt
from numba import jit

Nx = 72
Ny = 42

def h_new(h, Node, delta, k, flux_x, flux_y, i, j):
    if Node == 0:
        # interior cell
        h_n = (h[i+1,j] + h[i-1,j] + h[i,j-1] + h[i,j+1])/4
    elif Node == 1:
        # fixed value (Dirichlet)
        h_n = h[i,j]
    elif Node == 21:
        # no flux left
        h_n = (2*h[i+1,j] + h[i,j+1] + h[i,j-1])/4
    elif Node == 22:
        # no flux right
        h_n = (2*h[i-1,j] + h[i,j+1] + h[i,j-1])/4
    elif Node == 23:
        # no flux bottom
        h_n = (h[i+1,j] + h[i-1,j] + 2*h[i,j+1])/4
    elif Node == 24:
        # no flux top
        h_n = (h[i+1,j] + h[i-1,j] + 2*h[i,j-1])/4
    elif Node == 30:
        # no flux corner, interior
        h_n = (h[i-1,j] + h[i,j-1])/2
    elif Node == 31:
        # no flux corner, lower left outside
        h_n = (h[i+1,j] + h[i,j+1])/2
    elif Node == 32:
        # no flux corner, upper left outside
        h_n = (h[i+1,j] + h[i,j-1])/2
    elif Node == 33:
        #no flux corner, upper right outside
        h_n = (h[i-1,j] + h[i,j-1])/2
    elif Node == 34:
        # no flux corner, lower right outside
        h_n = (h[i-1,j] + h[i,j+1])/2
    elif Node == 41:
        # left/right change in k
        h_avg = (k[i+1,j]*h[i+1,j] + k[i-1,j]*h[i-1,j]) / (k[i+1,j] + k[i-1,j])
        h_n = (2*h_avg + h[i,j+1] + h[i,j-1])/4
    elif Node == 42:
        # top/bottom change in k
        h_avg = (k[i,j+1]*h[i,j+1] + k[i,j-1]*h[i,j-1]) / (k[i,j+1] + k[i,j-1])
        h_n = (2*h_avg + h[i+1,j] + h[i-1,j]) / 4
    elif Node == 51:
        # fixed flux from left to right
        h_n = (2*h[i+1,j] + 2*delta*(-flux_x[i,j]/k[i,j]) + h[i,j+1] + h[i,j-1]) / 4
    elif Node == 52:
        # fixed flux from right to left
        h_n = (2*h[i-1,j] + 2*delta*(-flux_x[i,j]/k[i,j]) + h[i,j+1] + h[i,j-1]) / 4
    elif Node == 53:
        # fixed flux from top to bottom
        h_n = (h[i-1,j] + h[i+1,j] + 2*h[i,j-1] + 2*delta*(-flux_y[i,j]/k[i,j])) / 4
    elif Node == 54:
        h_n = (h[i-1,j] + h[i+1,j] + 2*h[i,j+1] + 2*delta*(-flux_y[i,j]/k[i,j])) / 4
    else:
        h_n = -99
    return h_n

# delta is the length of each node
# node coordinates start at 0, and Nx/Ny ranges are all +1

k = np.ones((Nx, Ny))*10**-1
k[9:11, 4] = 10**-5
k[9:11, 5] = 10**-5
#set new value for k in range where different

# delta is the length of each node
# node coordinates start at 0, and Nx/Ny ranges are all +1

k = np.ones((Nx, Ny))*10**-1
k[9:11, 4] = 10**-5
k[9:11, 5] = 10**-5
#set new value for k in range where different

#flux as an array of 0
flux_x = np.ones((Nx, Ny))
flux_x[0,:] = 5

flux_y = np.ones((Nx, Ny))
flux_y[0,:] = 5
#same for flux_y if on a top boundary

@jit
def FinDiff(h, Node, delta, tol):
    err = tol + 1
    iters = 0
    lam = 1.8
    Nx, Ny = np.shape(h)
    while err > tol and iters < 10000:
        err = 0
        iters += 1
        for j in range(Ny):
            for i in range(Nx):
                h_o = h[i,j]
                h_n = h_new(h, Node[i,j], delta, k, flux_x[i,j], flux_y[i,j], i, j)
                h_n = lam*h_n + (1-lam)*h_o
                err = max(err, abs(h_n-h_o))
                h[i,j] = h_n
    return h, iters
